# 05-1 빠른 CPU를 위한 설계 기법

## 클럭

- 조금이라도 더 빠른 CPU를 만들기 위해서는 CPU를 어떻게 설계해야 할까?
- 4장에서 학습한 내용을 상기해보면,
    - 컴퓨터 부품들은 `클럭 신호`에 맞춰 일사불란하게 움직인다.
    - CPU는 명령어 사이클이라는 정해진 흐름에 맞춰 명령어들을 실행한다.
- 클럭 속도가 높은 CPU는 일반적으로 성능이 좋다. 그래서 클럭 속도는 CPU 속도 단위로 간주되기도 한다.
- 클럭 속도는 헤르츠(Hz) 단위로 측청하는데, 1초에 클럭이 몇 번 반복되는지 나타낸다.
    - ex) 2.5GHz → 1초에 25억번, 4.9GHz → 1초에 49억번 반복된다는 것을 나타냄
- 클럭 속도를 높이는 것은 CPU를 빠르게 하지만, 무작정 높이게 되면 발열 문제가 생긴다.

## 코어와 멀티코어

- 클럭 속도를 높이는 방법 외에는 CPU의 코어와 스레드 수를 늘리는 방법이 있다.
- 오늘날의 CPU는 ‘명령어를 실행하는 부품’에서 ‘명령어를 실행하는 부품을 여러 개 포함하는 부품’으로 명칭의 범위가 확장되었다.

!https://i.imgur.com/aisGRzF.png

### 코어

- 명령어를 실행하는 CPU 내 부품

### 멀티 코어 CPU (멀티코어 프로세서)

- 코어를 여러 개 포함하는 CPU
- 코어마다 처리할 연산이 적절히 분배되지 않는다면 코어 수에 비례하여 연산 속도가 증가하지 않는다.
- 또한, 처리하고자 하는 작업량보다 코어 수가 지나치게 많아도 성능에는 크게 영향이 없다.
- 중요한 것은 코어마다 처리할 명령어들을 얼마나 적절하게 분배하느냐이다.

## 스레드와 멀티스레드

> - **스레드**를 한 사람이 한 줄로 서서 일을 처리하는 상황으로 생각하자. 한 사람이 한 번에 한 가지 일을 처리한다.
- **멀티스레드**를 여러 사람이 여러 줄로 서서 동시에 일을 처리하는 상황으로 생각하자. 여러 사람이 동시에 일을 처리하여 작업이 더 빨리 끝나지만 여러 사람이 일을 하다 보니 서로의 작업이 충돌하지 않도록 조정이 필요하다.
>

### 스레드

- 사전적 의미는 ‘실행 흐름의 단위’
- CPU에서 사용되는 하드웨어적 스레드가 있고, 프로그램에서 사용하는 소프트웨어적 스레드가 있다.
- 하드웨어적 스레드
    - 하나의 코어가 동시에 처리하는 명령어 단위
    - 1코어 1스레드 : 명령어를 실행하는 부품 하나에 한 번에 하나씩 명령어를 실행하는 CPU를 의미
    - 멀티스레드
        - 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
        - 2코어 4스레드 : 명령어 실행하는 부품 두 개, 한 번에 네 개의 명령어를 처리할 수 있는 CPU
        - 8코어 16스레드 : 명령어 실행하는 부품 여덟 개, 한 번에 열여섯 개의 명령어를 처리할 수 있는 CPU, 코어 하나당 두 개의 하드웨어 스레드 처리.
- 소프트웨어적 스레드
    - 하나의 프로그램을 독립적으로 실행하는 단위
    - 아래의 기능을 동시에 수행시키기 위해 기능을 작동시키는 코드를 각각의 스레드로 만들면 동시에 실행할 수 있다.
        - 사용자로부터 입력 받은 내용을 화면에 보여주는 기능
        - 사용자가 입력한 내용이 맞춤법에 맞는지 검사하는 기능
        - 사용자가 입력한 내용을 수시로 저장하는 기능

> - **하드웨어적 스레드**를 도로 위의 차선이라고 생각하기. 여러 차선(하드웨어적 스레드)이 있으면 동시에 더 많은 자동차(작업)를 처리할 수 있다.
- **소프트웨어적 스레드**는 그 차선을 달리는 자동차라고 생각하기. 자동차(소프트웨어적 스레드)는 차선(하드웨어적 스레드)을 공유하며 달리지만, 하나의 차선에 여러 자동차가 달릴 수 있다.
>

- 멀티스레드 프로세서
    - 복수의 레지스터 세트를 통해서, 하나의 코어로 여러 명령어를 처리하도록 할 수 있다.
- 논리 프로세서
    - 메모리와 메모리에 저장된 프로그램 입장에서는 하드웨어 스레드와 코어를 구분 할 수 없다.
    - ‘한 번에 하나의 명령어를 처리하는 CPU’로, 각 하드웨어를 마치 하나의 단일 스레드/코어 프로세서로 인식하는데, 이런 점에서 하드웨어 스레드를 논리 프로세서라고 부르기도 한다.

## 정리

- 코어 : 명령어를 실행할 수 있는 ‘하드웨어 부품’
- 스레드 : 명령어를 실행하는 단위
- 멀티코어 프로세서 : 명령어를 실행할 수 있는 하드웨어 부품이 CPU 안에 두 개 이상 있는 CPU
- 멀티스레드 프로세서 : 하나의 코어로 여러 개의 명령어를 동시에 실행할 수 있는 CPU

# 05-2 명령어 병렬 처리 기법

CPU의 성능을 높일 수 있는 설계

- 높은 클럭 수
- 멀티 코어
- 멀티 스레드(멀티 프로세서)
- **명령어 병렬 처리 기법** : 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시키는 기법
    - 대표적인 기법 : 명령어 파이프라이닝, 슈퍼스칼라, 비순차적 명령어 처리

---

## 명령어 파이프라인

- 마치 공장 생산 라인과 같이 명령어들을 명령어 파이프라인에 넣고 동시에 처리하는 기법

!https://i.imgur.com/He4XYpE.png

- 파이프라인 위험 : 특정 상황에서 파이프라이닝이 성능 향상에 실패하는 경우
    - 데이터 위험
        - 명령어 간 ‘데이터 의존성’에 의해 발생한다.
        - 모든 명령어를 동시에 처리 할 수는 없다. 이전 명령어를 끝까지 실행해야만 실행할 수 있는 것도 존재한다.
        - 데이터 의존적인 두 명령어를 무작정 동시에 실행하려고 하면 파이프라인이 제대로 작동하지 않는 것
    - 제어 위험
        - 분기 등으로 인한 ‘프로그램 카운터의 갑자스러운 변화’에 의해 발생한다.
        - 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 갑작스러운 변화가 생기면 파이프라인에 미리 가지고 와서 처리 중이었던 명령어들은 아무 쓸모가 없어지는데 이를 제어 위험이라고 한다.
    - 구조적 위험
        - 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 동일한 자원을 사용하려 할 경우 발생

## 슈퍼스칼라

- CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조
- 공장 생산 라인을 여러 개 두는 것과 같다.
- 이론적으로는 파이프라인 개수에 비례하여 프로그램 처리 속도가 빨라지지만, 반드시 비례해서 빨라지지는 않는다. 데이터 위험, 제어 위험, 자원 위험을 피하기가 까다롭기 때문

## 비순차적 명령어 처리

- 합법적인 새치기라고 볼 수 있는데, 명령어를 순차적으로만 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법
- 비순차적 명령어 처리가 가능한 CPU 명령어들이 어떤 명령어와 데이터 의존성을 가지고 있는지, 순서를 바꿔 실행할 수 있는 명령어에는 어떤 것들이 있는지 판단할 수 있어야 함

# 05-3 CISC와 RISC

명령어 파이프라이닝과 슈퍼스칼라 기법을 실제로 CPU에 적용하려면 명령어가 파이프라이닝에 최적화되어 있어야 한다. 쉽게 말해 CPU가 파이프라이닝과 슈퍼스칼라 기법을 효과적으로 사용하려면 CPU가 인출하고 해석하고 실행하는 명령어가 파이프라이닝하기 쉽게 생겨야 한다.

'파이프라이닝 하기 쉬운 명령어'란 무엇인지 알아보자.

---

## 명령어 집합

- ISA(Instructino Set Architecture)
    - CPU가 이해할 수 있는 명령어들의 모음. 명령어 집합
    - 인텔 노트북 CPU는 x86-64 ISA를 이해하고, 애플의 아이폰 CPU는 ARM ISA를 이해한다. 둘은 서로의 명령어를 이해할 수 없다. ISA가 다르면 CPU가 이해할 수 있는 명령어, 어셈블리어도 달라진다.
    - CPU의 언어임과 동시에 CPU를 비롯한 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속
    - 명령어 병렬 처리 기법들을 도입하기 유리한 ISA에는 CISC와 RISC가 있다.

## CISC**(Complex Instruction Set Computer)**

- 복잡한 명령어 집합을 활용하는 컴퓨터(CPU)
- 이름 그대로 복잡하고 다양한 명령어들을 활용하는 CPU 설계 방식이다.
- 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양한 가변 길이 명령어를 활용하고, 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있다. 주소 지정 방식도 다양하다.
- 적은 수의 명령어로도 프로그램을 동작시킬 수 있다는 점은 메모리 공간을 절약할 수 있기 때문에, CISC는 메모리를 최대한 아끼며 개발해야 했던 시기에 인기가 높았다.
- 하지만 CISC에는 치명적인 단점이 있는데, 활용하는 명령어가 워낙 복잡하고 다양한 기능을 제공하기 때문에 명령어 크기, 실행되기까지의 시간이 일정하지 않다. 또한 복잡한 명령어 때문에 명령어 하나를 실행하는 데에 여러 클럭 주기를 필요로 한다.
- CISC가 활용하는 명령어는 명령어 수행 시간이 길고 가지각색이기 때문에 파이프라인이 효율적으로 명령어를 처리할 수 없다. 이는 현대 CPU에서 아주 치명적인 약점이다.
- 게다가 CISC가 복잡하고 다양한 명령어를 활용할 수 있다고는 하지만, 사실 대다수의 복잡한 명령어는 그 사용 빈도가 낮다.
- 정리
    - CISC 명령어 집합은 복잡하고 다양한 기능을 제공하기에 적은 수의 명령으로 프로그램을 동작시키고 메모리를 절약할 수 있지만, 명령어의 규격화가 어려워 파이프라이닝이 어렵다.
    - 대다수의 복잡한 명령어는 그 사용 빈도가 낮다.
    - 이런 이유로 CISC 기반 CPU는 성장에 한계가 있다.

## RISC(**Reduced Instruction Set Computer**)

- CISC에 비해 명령어의 종류가 적고, CISC와 다르게 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향한다.
- 즉, RISC는 고정 길이 명령어를 사용한다.
- 파이프라이닝에 최적화되어 있다.
- 메모리에 직접 접근하는 명령어를 load, store 두 개로 제한해 메모리 접근을 단순화하고 최소화했다. 그렇기에 CISC보다 주소 지정 방식의 종류가 더 적은 경우가 많다.

!https://i.imgur.com/LcCA41o.png

- CISC와 RISC의 차이

| CISC | RISC |
| --- | --- |
| 복잡하고 다양한 명령어 | 단순하고 적은 명령어 |
| 가변 길이 명령어 | 고정 길이 명령어 |
| 다양한 주소 지정 방식 | 적은 주소 지정 방식 |
| 프로그램을 이루는 명령어의 수가 적음 | 프로그램을 이루는 명령어의 수가 많음 |
| 여러 클럭에 걸쳐 명령어 수행 | 1클럭 내외로 명령어 수행 |
| 파이프라이닝 하기 어려움 | 파이프라이닝 하기 쉬움 |